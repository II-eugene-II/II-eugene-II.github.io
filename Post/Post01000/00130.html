<!DOCTYPE html>
<html>
  
<head>
    <meta charset="UTF-8">
    <title> 백준 25821번 </title>
    <link rel="stylesheet" href="/style.css">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- Google tag (gtag.js) -->
    <script type="text/javascript" src="/googleAnalytics.js"></script>
</head>

<body>
    <div id = "wrap">  
    <div class = "container">
        <header>
            <script type="text/javascript" src="/headerWrite.js"></script>
        </header>
    </div>
    <section>
    
    <div id = "postTitle"> 백준 25821번 - Palindromic Primes </div>
    
    <hr>
      
    <p>
      
    <blockquote>
        <a href="https://www.acmicpc.net/problem/25821"> 백준 25821번 문제 링크 </a> <br>
        문제 이름 : Palindromic Primes <br>
        주 언어 : Python <br>
        태그 : 브루트포스 알고리즘 / 수학 / 밀러-라빈 소수 판별법 / 정수론 / 소수 판정 <br>
        solved.ac 등급 : Platinum III (2023/01/27 확인)
    </blockquote>
      
    </p>
        
    <hr>
        
    <p>
      
    <details> <summary> 문제 보기 </summary>
    
        <p>
    
        <h4> 문제 : (번역 및 요약) </h4>

        팰린드롬 수는 앞에서부터 읽어도 뒤에서부터 읽어도 똑같은 수를 말합니다. (이 문제에서는 10진법에서) <br>

        소수란 1과 자기자신으로만 나누어 떨어지는 수를 의미합니다. <br>
        
        L 이상 H 이하의 팰린드롬인 소수의 개수를 출력해주세요. <br>
        
        <h4> 입력 : </h4>
        
        첫 줄에 L, H가 공백을 두고 입력된다. (H < $10^{12}$) <br>
        
        <h4> 출력 : </h4>
        
        L 이상 H 이하의 팰린드롬인 소수의 개수를 출력한다. <br> 
    
        </p>
    
    </details>

    <br>
        
    </p>
      
    <hr>
        
    <p>
        
    10진법에서 짝수자리인 펠린드롬 소수는 11밖에 없습니다. <br>

    11의 배수 판별법에 따라 모든 짝수자리의 펠린드롬 수는 홀수자리 숫자의 합 = 짝수자리 숫자의 합인지라 11의 배수인데, 11 그 자체는 소수이니 예외인 셈입니다. <br>

    따라서 H < $10^{12}$이라는 제한 조건이 있지만 $10^{11} < x < 10^{12}$인 팰린드롬 소수는 존재하지 않고 (12자리 수) $10^{11}$까지만 따져보면 됩니다. <br>

    일반적인 문제가 시간 제한이 0.5초, 1초, 2초, 3초 정도인데 시간 제한을 12초나 주었다는 것은, 오픈북 시험마냥 "풀 수 있으면 풀어봐라" 식으로 이해해야 합니다. 즉 시간이 엄청 오래 걸린다는 의미입니다. <br>

    따라서 최대한 최적화를 시킬 필요가 있습니다. <br>

    다른 부분은 접어두고 우선 $10^{10} < x < 10^{11}$ 사이의 펠린드롬 소수 (11자리수)가 몇개 있는지를 10초 정도 내에 찾아낼 수 있으면 범위 내에서는 넉넉하게 풀 수 있습니다. <br>

    두 가지 접근법이 있을 수 있는데, 소수를 먼저 찾고 팰린드롬인지 판단하는 것이냐, 혹은 팰린드롬인지 판단하고 소수인지 판단하는 것이냐가 있습니다. <br>
    
    이 범위 내에서의 모든 소수를 <a href="/Post/Post01000/00105.html"> 에라토스테네스의 체 </a> 같은걸로 만들어서 저장해놓으면 당연히 시간복잡도 $O(n \ln\ln{n})$에서 가능하지도 않고, 공간복잡도 $O(n)$에서 메모리 초과가 뜰 것입니다. (보통 파이썬에서는 1억까지 리스트도 만들기 힘듭니다.) <br>

    즉, 팰린드롬수를 만들어내서 그 수들을 소수인지 판단하는 것이 편하겠습니다. <br>

    11자리 수의 팰린드롬수 이므로, 그 수는 "a b c d e f e d c b a" 꼴의 수이고, a는 1부터 9까지, 나머지 수는 0부터 9까지 입니다. <br>

    a에 올 수 있는 수가 9가지이고, b, c, d, e, f에 올 수 있는 수가 각각 10가지이므로 90만번의 소수판별을 해야합니다. 아무래도 <a href="/Post/Post01000/00001.html"> $2$부터 $\sqrt{N}$까지 나누어보는 소수판별법 </a> 같은걸 썼다가는 시간초과가 확실히 날 것 같습니다. <br>

    우선 줄일 수 있는만큼 줄여보자면, a에 올 수 있는 수는 사실 미리 처리할 수 있습니다. <br>

    a에 2, 4, 6, 8이 오면 "a b c d e f e d c b a"는 짝수가 되므로 무조건 소수가 아닙니다. 따라서 a에 올 수 있는 수는 1, 3, 5, 7, 9로 5가지가 되고, 따라서 50만번 소수판별을 하면 됩니다. <br>

    사실 10만번 더 줄일 수 있습니다. a == 5이면 "a b c d e f e d c b a"는 5의 배수이므로 무조건 소수가 아닙니다. 따라서 a에 올 수 있는 수는 1, 3, 7, 9로 4가지가 되고, 40만번의 소수판별만 남습니다. <br>

    아파트 임대 (백준 5615)가 10만번의 소수판별인데, 그거보다 더 심한 문제인 셈입니다. <br>

    그래도 12초인 만큼, <a href="/Post/Post01000/00006.html"> 밀러-라빈 소수 판별법 </a>을 써주면 시간 내로는 풀 수 있을 것으로 보입니다. <br>

    <script src="https://gist.github.com/II-eugene-II/087914e87b7d6e181535c00b8f9cefd2.js"></script> <br>

    isPrime + MRTest 함수에서 소수판별을 담당하고, PalindPrime 함수는 L이상 H이하의 2K + 1자리 소수의 개수를 세는 함수입니다. <br>

    a = str(j).zfill(K)를 하면, j = 3, k = 4라고 하면 0003을 만들어줍니다. a[::-1]은 이를 뒤집어서 붙여주는 식입니다. <br>

    11의 경우가 짝수자리이면서 펠린드롬 소수인 유일한 예외인데 이거까지 감안해서 함수 만들기는 머리아파지니 그냥 2부터 11까지는 논외로 쳐주고 일일이 더해줍니다. <br>

    PyPy3도 아니고 Python3에서도 이정도 코드로 6초 안에 통과하니 C나 C++ 같은 경우도 2K + 1자리의 팰린드롬 수를 어떻게 만들지만 신경쓰셔서 만드시면 시간 내로 넉넉하게 통과하실 수 있습니다. <br>

    <hr>

    사실 더 빠르게 푸는 법이 있습니다. <a href="/Post/Post01000/00008.html"> Poulet Number </a> (유사소수)를 이용한 풀이인데, <a href="/Post/Post01000/00005.html"> 페르마의 소정리 </a>에 따라 모든 홀수 소수 $p$는 $2^{p - 1} \equiv 1 \pmod{p}$를 만족합니다. <br>
    
    해당 문제에서 주어진 L, H 범위 내에서 일의자리가 1, 3, 7, 9이면서 $2^{N - 1} \equiv 1 \pmod{N}$인 합성수가 <b> 딱 한 가지 </b> 존재하는데, <br>
    
    이것만 따로 처리해주고 isPrime(N) 함수를 "$2^{N - 1} \equiv 1 \pmod(N}$ is True?"로 바꿔주면 됩니다. 그 수를 여기다가 쓰면 문제가 너무 쉬워져버릴테니 한번 그 수를 직접 찾아보시는 것을 추천드립니다. <br>

    </p> <!-- 59에 관한 이야기도... -->
        
    <hr>
        
    <p>

    원래 제가 이 문제 처음 풀었을 때는 골드 1이어서 그래도 밀러-라빈 쓰는거 감안하고 5615번이 "소수판정 문제 + 소수판정 문제임을 알아차리는데 까지의 발상"이 합쳐져서 플레 1이니 플레 2는 줘야겠지...하면서 난이도 투표에서 플레 2를 주니 바로 문제 난이도가 플레 5로 올라가버렸습니다; <br>

    그 뒤에 한 분이 푸시고 플레 1을 투표하셔서 플레 4까지 오른걸 봤는데, 그 뒤에 또 한분이 플레 1을 투표하셔서 지금 이 문제가 갑자기 플레 3 문제까지 올라갔습니다. <br>

    아무리 그래도 소수판별 40만번 해야하는데 골드 1은 좀...아닌듯 합니다. <br>
        
    -번째 푼 문제 (2023/--/--) <br>
        
    </p>
      
    </section>
    <aside>
        <script type="text/javascript" src="/asideWrite.js"></script>
    </aside>
    
    <footer>
        <script type="text/javascript" src="/footerWrite.js"></script>
    </footer>
      
    </div> <!-- wrap -->
    
    <script type="text/javascript" src="/LaTexWrite.js"></script>

</body>
</html>
