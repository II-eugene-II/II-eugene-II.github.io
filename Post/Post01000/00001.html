<!DOCTYPE html>
<html>
  
<head>
    <meta charset="UTF-8">
    <title> 기본적인 소수 판별법 </title>
    <link rel="stylesheet" href="/style.css">
</head>

<body>
    <div id = "wrap">  
    <div class = "container">
        <header>
            <script type="text/javascript" src="/headerWrite.js"></script>
        </header>
    </div>
    <section>
    
    <div id = "postTitle"> 기본적인 소수 판별법 </div>
    
    <hr>
      
    <p>
      
    <blockquote>
        1과 자기 자신만을 약수로 가지는 수를 <b>소수</b>라고 한다.
    </blockquote>
      
    a를 b로 나누었을 때 나머지가 0이면 약수라 할 수 있습니다. <br>
      
    예를 들어, $15$를 $3$으로 나누면 몫이 5, 나머지가 0이므로 $(15 = 3 \times 5 + 0)$ 3은 15의 약수입니다. <br>
      
    $15$를 $4$으로 나누면 몫이 3, 나머지가 3이므로 $(15 = 4 \times 3 + 3)$ 4는 15의 약수가 아닙니다. <br>
      
    당연히 모든 자연수 $N$에 대하여 $1$로 나누면 나머지가 0이고 $(N = 1 \times N + 0)$, $N$으로 나누면 나머지가 0이므로($N = N \times 1 + 0$) <br>
      
    이를 제외해주면 다음과 같은 정의를 할 수 있습니다. <br>
      
    <blockquote>
        자연수 $N$에 대해서, $2 \leq m \leq N - 1$인 모든 자연수 $m$에 대하여 $N$을 $m$으로 나눈 나머지가 0이 아니라면 (즉, $N$이 $2 \leq m \leq N - 1$인 약수 $m$이 없다면) <br>
        $N$은 <b>소수</b>라고 할 수 있다.
    </blockquote>
      
    따라서 어떤 자연수 $N$이 소수임을 판단하는 가장 쉽고 간단한 방법은 $N$을 일일이 $2$부터 $N-1$까지 나눠서, 모두 나머지가 $0$이 아니라면 $N$은 소수라고 할 수 있습니다. <br>
      
    <h3> 방법 1. $N$을 일일이 $2$부터 $N - 1$까지 나눠보기 </h3>
      
    이를 위해서 보통 코딩을 할때 isPrime(n) 함수를 만들곤 합니다. </p>
      
    <p>
    
    <script src="https://gist.github.com/II-eugene-II/1bf84dacb7089d8d496131ecb390d46b.js"></script>
    
    </p>
      
    <p> (입력되는 수가 1보다 큰 자연수라는 보장이 있으면 "if(N == 1): return False" 부분은 빼도 좋습니다.) <br>
      
    물론 진짜 $N-1$까지의 수로 모두 나눠보는것은 비효율적입니다. <br>
      
    $N$이 1조에 가까운 어떤 수라고 가정하면 말 그대로 1조번의 연산이 필요할 수 있습니다. 따라서 조금 더 빠르게 할 수 있는 방법을 생각해야합니다. <br>
      
    어떤 두 소수 $p$, $q$에 대하여 $N=pq$라 한다면, 두 소수중 하나는 필수적으로 $\sqrt{N}$보단 작을 것입니다. <br>
      
    만약 두 소수 $p$, $q$가 $p > \sqrt{N}$, $q > \sqrt{N}$이면 $pq > \sqrt{N} \times \sqrt{N} = N$에서 $pq>=N$인데, $N=pq$ 라 했으므로 모순입니다. <br>
      
    따라서 $N$을 $2$부터 $\sqrt{N}$까지만 (정확히는 $\sqrt{N}$를 올림한) 나눠봐도 충분합니다. <br>
      
    <h3> 방법 2. $N$을 $2$부터 $\lceil \sqrt{N} \rceil$까지만 나눠보기 </h3> </p>
  
    <p>
      
    <script src="https://gist.github.com/II-eugene-II/9b31b91d3118d463f7b0f010753740e8.js"></script>
      
    </p>
      
    <p> 방법 2보다도 2배 더 빠르게 하는 법이 있습니다. <br>
      
    $2$로만 나누고 나면 짝수로 나눌 필요가 없습니다. <br>
      
    $N$을 $2$로 나눈 나머지가 $1$이었다면 $N$은 홀수이므로, $N$을 다른 짝수로 나눠봐도 어차피 나머지가 $0$이 아니라는 자명한 결과가 나옵니다. <br>
    
    따라서 $2$로만 먼저 나누어보고, 그 다음으로는 홀수로만 계속 나눠봅니다. <br>
      
    <h3> 방법 3. $N$을 우선 $2$로 나눠보고, $3$부터 $\lceil \sqrt{N} \rceil$ 의 홀수로만 나눠보기 </h3> <br>
      
    $\lceil \sqrt{N} \rceil$까지 $2$ 이외의 짝수를 배제했으므로, 방법 2보다 2배 빨리 판정할 수 있습니다. (홀수/짝수 비중이 반반이므로) <br>
      
    </p>
  
    <p>
    
    <script src="https://gist.github.com/II-eugene-II/ca470b0d5d395d01ff13e3c36de88e63.js"></script>
    
    </p>
  
    <p> 방법 3보다 또 1.5배 더 빠르게 하는 방법이 있습니다. <br>
      
    방법 2에서는 짝수를 배제했던 것처럼, 추가적으로 배제할 수 있는 숫자들이 존재합니다. <br>
      
    모든 자연수는 6으로 나눈 나머지가 0, 1, 2, 3, 4, 5 뿐입니다. <br>
      
    $6k + 1 = 1, 7, 13, 19, 25, 31, \cdots$ (나머지 1)<br>
    $6k + 2 = 2, 8, 14, 20, 26, 32, \cdots$ (나머지 2)<br>
    $6k + 3 = 3, 9, 15, 21, 27, 33, \cdots$ (나머지 3)<br>
    $6k + 4 = 4, 10, 16, 22, 28, 34, \cdots$ (나머지 4)<br>
    $6k + 5 = 5, 11, 17, 23, 29, 35, \cdots$ (나머지 5)<br>
    $6k + 6 = 6, 12, 18, 24, 30, 36, \cdots$ (나머지 6)<br>
      
    방법 3에서 $2$를 제외한 모든 짝수를 날려버렸으니, $6k + 2$, $6k + 4$, $6k + 6$ 꼴의 수를 날려버린 셈입니다. <br>
      
    여기서 $6k+3$꼴의 수들도, $3 \times (2k + 1)$ 꼴로 쓸 수 있으니, $3$을 제외하고 전부 날려버릴 수 있습니다. <br>
      
    $3$으로 나누어봤을 때 나머지가 $0$ 이 아니었는데 $9$, $15$, $21$, $27$...등으로 나누어봐도 어차피 나머지가 $0$이 아닐 것이란걸 알고 있기 때문입니다. <br>
      
    <h3> 방법 4. $N$을 우선 $2$와 $3$으로 나눠보고, $5$부터 $\lceil \sqrt{N} \rceil$ 까지의 $6k \pm 1$ 유형의 수로만 나눠보기 </h3> <br>
      
    방법 3에서 $6k + 1$, $6k + 3$, $6k + 5$ 꼴의 수만 남겼고, 이번에 $6k + 3$ 꼴의 수를 또 날렸으므로 방법 3보다 1.5배 빨리 판정할 수 있습니다. (3번 할 일을 2번만 하므로) <br>
      
    </p>
  
    <p>
    
    <script src="https://gist.github.com/II-eugene-II/acc0c3aaab68a583cfd345525af483de.js"></script>
    
    </p>
  
    <p> 정수론의 성질을 이용하여 소수 대신 합성수 대다수를 <b>아주 빠르게</b> 판단할 수는 있습니다. <br>
      
    <a href="/Post/Post01000/00005.html"> 페르마의 소정리 </a>에 따라, $p$가 소수이면 $p$와 서로소인 자연수 $a$에 대하여 $a^{p - 1} \equiv 1 \pmod{p}$ 입니다. <br>
      
    정수론 같은건 모르겠다라고 하시는 분들은, 그냥 일일이 나눠보기 직전에 "if pow(2, N-1, N) != 1 : return False"만 넣어보셔도 대다수의 합성수를 빠르게 거른다는 사실을 알 수 있습니다. <br>
      
    물론, Poulet Number, 카마이클 수 같은 일부 이상한 수들은 걸러내지 못하지만, 그래도 기존의 코드와는 비교도 못하게 빨라집니다.
      
    <h3> 방법 5. $N$을 $2$에 대한 페르마 판정법("if pow(2, N-1, N) != 1 : return False")시행 후 일일이 나눠보기 </h3> <br>
      
    시간복잡도는 최선의 경우 Ω(ln N), 최악의 경우 O($\sqrt{N}$) 입니다. <br>
      
    </p>
  
    <p>
    
    <script src="https://gist.github.com/II-eugene-II/9b7fb89cd86d493ad55915c518b3de02.js"></script>
    
    </p>

    <p> 아직도 느리다라고 생각되시는 분들에게 적합한 소수 판별법이 있습니다. <br>
      
    앞에서 이용한 정수론의 성질을 더 이용해서 만드는, 굉장히 빠른 <a href="/Post/Post01000/00006.html"> 밀러-라빈 소수판별법 </a>도 존재합니다. <br>
      
    구현하는건 약간의 지식이 필요하지만, 더더욱 복잡한 소수 판별법들보단 만들기 쉽고 빠릅니다. (<b>타원곡선</b> 소수 판별법 같은거보다는 훨씬 낫습니다..)
      
    </p>
      
    </section>
    <aside>
        <script type="text/javascript" src="/asideWrite.js"></script>
    </aside>
    
    <footer>
        <script type="text/javascript" src="/footerWrite.js"></script>
    </footer>
      
    </div> <!-- wrap -->
    
    <script type="text/javascript" src="/LaTexWrite.js"></script>

</body>
</html>
